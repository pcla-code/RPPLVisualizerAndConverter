<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" href="../assets/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="/libraries/rppl.css">
    <base target="_top">
	
	<script src="./../libraries/chart.umd.js"></script>
	<script src="./../libraries/papaparse.min.js"></script>
  </head>
  <body>


    <!-- HEADER -->
    <header class="header">
        <div class="logo-container">
            <img src="/assets/logo.svg" alt="RPPL Logo" class="logo">
			<!--
            <h1 class="title" style="margin-top: 10px;">Visualizer 4.2.2025</h1>
			-->
			<div class="title-container">
				<h1 class="title" style="margin-top: 0px;">Visualizer 4.2.2025</h1>
				<p id="logged-in-user" class="username-display">Logged in as: <span>Fetching...</span></p>
			</div>
        </div>
		
		<!-- MENU ADDED -->
		<nav class="header-menu">
			<a href="RPPL_LocalVisualizerCORS.html">Visualizer</a>
			<a href="dashboardSample.html">Dashboard Sample</a>
			<a href="dashboard.html">Dashboard</a>
		</nav>		
    </header>

    <!-- MAIN CONTAINER -->
    <div class="container">
        
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="filters">

                <h2>Data Source</h2>
                <select id="datasource1" onchange="fetchCSVData()"></select>     
				
				<h2>Primary Filter</h2>
                <select id="primary1" onchange="updatePrimary2Options();"></select>
                <select id="primary2" multiple onchange="updateChart()"></select>

                <h2>Secondary Filters</h2>
                <select id="secondary1" multiple onchange="updateChart();"></select>

                <h2>Outcomes</h2>
                <select id="outcomes1" multiple onchange="updateChart()"></select>

                <h2>Aggregation Options</h2>
                <div id="aggregationOptions" onchange="updateChart()">
                    <label><input type="radio" name="stat" value="frequency" checked> Frequency</label><br>
                    <label><input type="radio" name="stat" value="mean" > Mean</label><br>
                    <label><input type="radio" name="stat" value="median"> Median</label><br>
                    <label><input type="radio" name="stat" value="mode"> Mode</label><br>                   
                </div>
                        
                <h2>Presets</h2>
                <select id="presets1" onchange="updateChartUsingPreset()"></select>
                <button id="addPresetButton" class="primary-btn">Add as Preset</button>
                <button id="exportPresetsButton" class="primary-btn">Export Presets</button>

				<input type="file" id="importPresetsInput" accept=".json">

				<!-- Styled label as a button -->
				<label for="importPresetsInput" class="file-upload-label primary-btn">
					Upload Presets
				</label>
            </div>
			<br><br><br>
        </aside>

        <!-- CHART AREA with Enlarged Glassmorphism -->
        <main class="chartArea">
            <div class="glass-container">
                <div class="loading-spinner">Initializing...</div>
                <canvas id="myChart"></canvas>
            </div>
        </main>
    </div>

    <!-- FOOTER -->
    <footer class="footer">
        &copy; 2025 RPPL. All Rights Reserved.
    </footer>

      <script>

		
		function fetchUsername() {
			const clientIP = window.location.hostname;
			const localFetchURL = `http://127.0.0.1:9000/get-username`; // Try local first
			const mainServerFetchURL = `http://${clientIP}:8000/username`; // Dynamic IP for main server

			console.log("Client IP:", clientIP);
			console.log("Trying to fetch from:", localFetchURL);

			fetch(localFetchURL)
				.then(response => {
					if (!response.ok) throw new Error("Local username fetch failed.");
					return response.json();
				})
				.then(data => {
					console.log("✅ Local Username:", data.username);
					document.querySelector("#logged-in-user span").textContent = data.username;
					filterCSVFiles(data.username);
				})
				.catch(error => {
					console.warn("❌ Local fetch failed. Trying main server...", error);

					// Only try the main server if the local one fails
					fetch(mainServerFetchURL)
						.then(response => {
							if (!response.ok) throw new Error("Main server username fetch failed.");
							return response.text();
						})
						.then(username => {
							console.log("✅ Main Server Username:", username);
							document.querySelector("#logged-in-user span").textContent = username;
							filterCSVFiles(username);
						})
						.catch(fallbackError => {
							console.error("❌ Error fetching username from both sources:", fallbackError);
							document.querySelector("#logged-in-user span").textContent = "Unknown User";
						});
				});
		}
		
		function filterCSVFiles(username) {
			Papa.parse("../config/access.csv", {
				download: true,
				header: true,
				complete: function(results) {
					const rows = results.data;

					// Find the row for the user (or fallback to 'admin')
					const userRow = rows.find(row => row.username === username) ||
									rows.find(row => row.username === 'admin');

					if (!userRow) {
						console.warn("⚠️ No permissions found for user:", username);
						return;
					}

					// Get all filenames where the user has a 'y'
					const assignedCSVs = Object.keys(userRow)
						.filter(key => key !== "username" && userRow[key].trim().toLowerCase() === 'y');

					console.log("📂 Files for", username, "→", assignedCSVs);

					const datasourceSelect = document.getElementById("datasource1");
					datasourceSelect.innerHTML = "";

					assignedCSVs.forEach(file => {
						const option = document.createElement("option");
						option.value = file;
						option.textContent = file;
						datasourceSelect.appendChild(option);
					});

					// Auto-fetch first file if needed
					fetchCSVData();
				}
			});
		}

		// Ensure the function runs after the DOM is fully loaded
		document.addEventListener("DOMContentLoaded", fetchUsername);








		
        let myChart = document.getElementById("myChart").getContext('2d');
        let localChart;

        var JSLIST;
        var JSLISTprime;

        /*****************************
         * FETCH DATA FROM SHEET
        *****************************/

		const csvFiles = ['SchoolLeaderSurvey.csv']


		function populateDataSourceDropdown() {
			const datasourceDropdown = document.getElementById('datasource1');

			// Clear existing options
			datasourceDropdown.innerHTML = '';

			// Populate dropdown with options
			csvFiles.forEach(file => {
				const option = document.createElement('option');
				option.textContent = file; // Display file name
				option.value = file; // Use file name as value
				datasourceDropdown.appendChild(option);
			});

			// Set a default value
			datasourceDropdown.value = csvFiles[0];
		}

		// Call the function to populate the dropdown on page load
		populateDataSourceDropdown();

		function fetchCSVData() {
			const selectedDataSource = `../data/${document.getElementById('datasource1').value}`;
			fetch(selectedDataSource)
				.then(response => response.text())
				.then(csvData => {
					// Reset filters
					resetFilters();
					// Parse new CSV data
					parseCSVData(csvData);
				})
				.catch(error => handleError(error));
		}

		function resetFilters() {
			const primary1 = document.getElementById('primary1');
			const primary2 = document.getElementById('primary2');
			const secondary1 = document.getElementById('secondary1');
			const outcomes1 = document.getElementById('outcomes1');

			primary1.innerHTML = '<option value="">Select...</option>';
			primary2.innerHTML = '<option value="">Select...</option>';
			secondary1.innerHTML = '<option value="">Select...</option>';
			outcomes1.innerHTML = '<option value="">Select...</option>';
		}


		
		
		document.getElementById('datasource1').addEventListener('change', function() {
			// alert("this fired");
			fetchCSVData();
		});



		function handleFiles(files) {
			const fileToRead = files[0];
			const reader = new FileReader();
			reader.readAsText(fileToRead);
			reader.onload = function(event) {
				const csvData = event.target.result;
				parseCSVData(csvData);
			};
		}
		
		
		function parseCSVData(csvData) {
			Papa.parse(csvData, {
				header: true, // Parse the CSV data as an array of objects
				complete: function(results) {
					console.log("Parsed Results:", results.data);
					const convertedData = convertToArrayOfArrays(results.data);
					console.log("New CSV Headers:", convertedData[0]); // Log the headers
					displayData(convertedData);
				}
			});
		}

		
		function convertToArrayOfArrays(data) {
		  if (data.length === 0) return [];

		  // Extract the headers
		  const headers = Object.keys(data[0]);

		  // Extract the rows and perform necessary conversions
		  const rows = data.map(row => {
			return headers.map(header => {
			  let value = row[header];

			  // Convert dates to ISO format
			  if (header.includes('Timestamp') && value) {
				const dateParts = value.split('/');
				if (dateParts.length === 3) {
				  const day = dateParts[0].padStart(2, '0');
				  const month = dateParts[1].padStart(2, '0');
				  const year = dateParts[2];
				  value = `${year}-${month}-${day}T00:00:00.000Z`;
				}
			  }

			  // Convert numeric strings to numbers
			  if (!isNaN(value) && value.trim() !== '') {
				value = Number(value);
			  }

			  return value;
			});
		  });

		  // Combine headers and rows
		  return [headers, ...rows];
		}



        /***************************
        * DisplayData function is the first function called after fetching data from spreadsheet
        ***************************/

		
		function displayData(data) {
		  window.JSLIST = data;
		  console.log("JSLIST:", JSLIST);

		  window.JSLISTprime = transposeArray(JSLIST);
		  console.log("JSLISTprime:", JSLISTprime);

		  let primary1 = document.getElementById("primary1");
		  let primary2 = document.getElementById("primary2");
		  let secondary1 = document.getElementById("secondary1");
		  let outcomes1 = document.getElementById("outcomes1");

		  // Add "ALL" options
		  ["ALL"].forEach(item => {
			[primary2, secondary1].forEach(select => {
			  let option = document.createElement("option");
			  option.text = item;
			  option.value = item;
			  select.add(option);
			});
		  });

		  // Populate primary1 and outcomes1 dropdowns
		  JSLIST[0].forEach((item, index) => {
			let option1 = document.createElement("option");
			option1.text = item;
			option1.value = item;
			primary1.add(option1);

			let option2 = document.createElement("option");
			option2.text = item;
			option2.value = item;
			outcomes1.add(option2);
		  });

		  // Default selections
		  primary1.selectedIndex = 1;  // Example: third index for primary <- note to self @neithan
		  outcomes1.selectedIndex = 5;  // Example: eighth index for outcomes
		  document.querySelector('input[name="stat"][value="frequency"]').checked = true; // Default to 'frequency'

		  // Populate primary2 and secondary1 with default or specific values
		  updateSelections(primary1.value);

		  primary2.selectedIndex = 0;
		  secondary1.selectedIndex = 0;

		  // Create an initial chart first
		  updateChart();
		}


		function updateSelections(selectedColumn) {
			let primary2 = document.getElementById("primary2");
			let secondary1 = document.getElementById("secondary1");
			let columnIndex = JSLIST[0].indexOf(selectedColumn); // Find the index of the selected column
			let columnValues = new Set(JSLIST.slice(1).map(row => row[columnIndex]));  // Get unique values from the selected column

			[primary2, secondary1].forEach(select => {
				// Clear existing options except "ALL"
				Array.from(select.options).forEach(option => {
					if (option.value !== "ALL") select.remove(option);
				});
				// Add new options
				columnValues.forEach(value => {
					let option = document.createElement("option");
					option.text = value;
					option.value = value;
					select.add(option);
				});
			});
		}

        function handleError(error) {
          console.error(error);
          alert("There was an error fetching data: " + error);
        }

        // fetchDataFromSheet();
		// window.handleFiles = handleFiles;
		fetchCSVData();

        /****************************
        * ALL HELPER FUNCTIONS HERE INCLUDING MAIN UPDATE CHART FUNCTION
        ****************************/

        // this transposes JSLIST so that each array in the arraylist has the structure [header, value1, value2, value3]
        function transposeArray(array) {
         
          const numRows = array.length;
          const numCols = array[0].length;

        
          const transposedArray = [];

         
          for (let i = 0; i < numCols; i++) {
            const newRow = [];
            for (let j = 0; j < numRows; j++) {
              newRow.push(array[j][i]);
            }
            transposedArray.push(newRow);
          }

          return transposedArray;
        }

        // universal number randomizer
        function getRandomInteger(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }


		
// Update Primary2 function
function updatePrimary2Options() {
    console.log('FIRE UPDATEPRIMARY2');
    
    const selectedPreset = document.getElementById('presets1').value;
    const selectedDataSource = document.getElementById('datasource1').value;
    const preset = window.customPresets[selectedPreset];
    console.log("Preset Details inside Primary2: ", preset);  // Log the preset details

    const primary1 = document.getElementById("primary1");
    const primary2 = document.getElementById("primary2");
    primary2.innerHTML = ''; // Clear existing options

    // Add the 'ALL' option by default
    const allOption = document.createElement("option");
    allOption.text = "ALL";
    allOption.value = "ALL";
    primary2.add(allOption);

    // Get the selected column name from primary1
    const selectedColumn = primary1.value;

    // Find the index of the selected column in JSLIST's first row (column headers)
    const columnIndex = JSLIST[0].indexOf(selectedColumn);
    if (columnIndex === -1) {
        console.error('Selected column not found in JSLIST');
        return;
    }

    // Extract unique values from the selected column across all rows
    const uniqueValues = Array.from(new Set(JSLIST.slice(1).map(row => row[columnIndex]))); // Skip the header row

    // Populate primary2 with options based on unique values
    uniqueValues.forEach(value => {
        let option = document.createElement("option");
        option.text = value;
        option.value = value;
        primary2.add(option);
    });

    // Handle preset data for primary2
    if (preset && preset.primary2 && Array.isArray(preset.primary2)) {
        // Deselect all options first
        Array.from(primary2.options).forEach(option => option.selected = false);

        // Use preset.primary2 as indices to select the appropriate options
        preset.primary2.forEach(index => {
            if (primary2.options[index]) {
                primary2.options[index].selected = true; // Select by index
            } else {
                console.warn(`Index ${index} is out of bounds for primary2 dropdown`);
            }
        });
    } else {
        // If no preset or primary2 data, default to selecting "ALL"
        primary2.value = "ALL";
    }

    updateChart();
}



        // UPDATE CHART HELPER FUNCTIONS
        function filterData(primary1Value, primary2Values, secondary1Values, outcomes1Values) {
            // Placeholder: Filter JSLIST based on selections
            // Return filtered data
            return JSLIST; // Temporarily return the full dataset
        }

        function processData(filteredData, outcomes1Values) {
            // Placeholder: Process filtered data to create datasets for Chart.js
            // Return datasets
            return []; // Temporarily return an empty array
        }


function renderChart(chartData) {
    const ctx = document.getElementById('myChart').getContext('2d');
    
    // Retrieve selections
    const primary1Value = document.getElementById('primary1').value; // Bold and all caps
    const primary2Values = Array.from(document.getElementById('primary2').selectedOptions)
                        .map(option => option.value)
                        .join(', ');
    const secondary1Values = Array.from(document.getElementById('secondary1').selectedOptions)
                        .map(option => option.value)
                        .join(', ');
    const outcomes1Value = document.getElementById('outcomes1').value; // Bold and all caps

    // Format title
    const titleText = `${primary1Value} (${primary2Values ? `${primary2Values}` : 'All'} - ${secondary1Values ? `${secondary1Values}` : 'All'}) x ${outcomes1Value}`;

    if (localChart) {
        localChart.destroy(); // Destroy the old chart instance if it exists
    }

    // Background color plugin
    const backgroundColorPlugin = {
        id: 'customCanvasBackgroundColor',
        beforeDraw: (chart) => {
            const ctx = chart.ctx;
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // Set to any color you want
            ctx.fillRect(0, 0, chart.width, chart.height);
            ctx.restore();
        }
    };

    localChart = new Chart(ctx, {
        type: 'bar', // You may dynamically change this based on data type
        data: {
            labels: chartData.labels, // Use labels from processed data
            datasets: chartData.datasets // Use datasets from processed data
        },
        plugins: [backgroundColorPlugin],
        options: {
            plugins: {
                title: {
                    display: true,
                    text: titleText,
                    font: {
                        size: 18
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(tooltipItem) {
                            return tooltipItem.dataset.label + ': ' + tooltipItem.parsed.y;
                        }
                    }
                }                
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });

    // localChart.style.backgroundColor = 'rgba(255,0,0,255)';
	const currentFile = document.getElementById('datasource1').value;
	const selectedOutcome = document.getElementById('outcomes1').value;
	addComparisonAverageLines(localChart, currentFile, selectedOutcome);
}
 
 
/*
async function addComparisonAverageLines(chartInstance, currentFilename, outcomeColumn) {
  const outcomeLabels = chartInstance.data.labels;
  const stat = document.querySelector('input[name="stat"]:checked').value;

  // Find outcome column index in JSLIST (for org data)
  const outcomeIndex = JSLIST[0].indexOf(outcomeColumn);
  if (outcomeIndex === -1) return;

  const groupByCol = document.getElementById('primary1').value;
  const groupByIndex = JSLIST[0].indexOf(groupByCol);

  const thisOrgData = JSLIST.slice(1);

  // Fetch access.csv and extract all file names mentioned
  let allOtherData = [];
  try {
    const accessRes = await fetch('../config/access.csv');
    const accessText = await accessRes.text();
    const parsedAccess = Papa.parse(accessText, { header: true }).data;
    const allFiles = Object.keys(parsedAccess[0] || {}).filter(key => key !== 'username');

    const baseName = currentFilename.replace(/\d*\.csv$/, '');
    const otherFiles = allFiles.filter(name => name.startsWith(baseName) && name !== currentFilename);

    // Load each of the other files
    for (let file of otherFiles) {
      try {
        const resp = await fetch(`../data/${file}`);
        if (resp.ok) {
          const text = await resp.text();
          const parsed = Papa.parse(text, { header: true }).data;
          allOtherData.push(...parsed);
        }
      } catch (e) {
        console.warn('Error loading file:', file);
      }
    }
  } catch (err) {
    console.error("Failed to load access.csv or files:", err);
    return;
  }
  
	function averageCountsPerLabel(dataSet) {
	  const grouped = {};

	  dataSet.forEach(row => {
		const group = row[groupByCol];
		const value = row[outcomeColumn];
		if (!group || value === undefined) return;

		if (!grouped[group]) grouped[group] = {};
		if (!grouped[group][value]) grouped[group][value] = [];

		const parsedValue = parseFloat(value);
		grouped[group][value].push(isNaN(parsedValue) ? value : parsedValue);
	  });

	  const labelAvgs = outcomeLabels.map(label => {
		let total = 0;
		let count = 0;

		Object.values(grouped).forEach(labelGroup => {
		  const values = labelGroup[label];
		  if (!values || values.length === 0) return;

		  count++;
		  switch (stat) {
			case 'frequency':
			  total += values.length;
			  break;
			case 'mean':
			  const numeric = values.filter(v => typeof v === 'number');
			  const mean = numeric.reduce((a, b) => a + b, 0) / numeric.length || 0;
			  total += mean;
			  break;
			case 'median':
			  const sorted = values.filter(v => typeof v === 'number').sort((a, b) => a - b);
			  const mid = Math.floor(sorted.length / 2);
			  const median = sorted.length % 2 === 0
				? (sorted[mid - 1] + sorted[mid]) / 2
				: sorted[mid];
			  total += median || 0;
			  break;
			default:
			  break;
		  }
		});

		return count > 0 ? total / count : 0;
	  });

	  return labelAvgs;
	}
  
  const orgAvg = averageCountsPerLabel(thisOrgData);
  const othersAvg = averageCountsPerLabel(allOtherData);

  chartInstance.data.datasets.push({
    label: 'Org Avg',
    data: orgAvg,
    type: 'line',
    borderColor: '#36a2eb',
    borderDash: [5, 5],
    fill: false,
    pointRadius: 0
  });

  chartInstance.data.datasets.push({
    label: 'Other Orgs Avg',
    data: othersAvg,
    type: 'line',
    borderColor: '#aaa',
    borderDash: [2, 3],
    fill: false,
    pointRadius: 0
  });

  chartInstance.update();
}
*/

async function addComparisonAverageLines(chartInstance, currentFilename, outcomeColumn) {
  const outcomeLabels = chartInstance.data.labels;
  const stat = document.querySelector('input[name="stat"]:checked').value;

  // Find outcome column index in JSLIST (for org data)
  const outcomeIndex = JSLIST[0].indexOf(outcomeColumn);
  if (outcomeIndex === -1) return;

  const groupByCol = document.getElementById('primary1').value;
  const groupByIndex = JSLIST[0].indexOf(groupByCol);

  const thisOrgData = JSLIST.slice(1);

  // Fetch access.csv and extract all file names mentioned
  let allOtherData = [];
  try {
    const accessRes = await fetch('../config/access.csv');
    const accessText = await accessRes.text();
    const parsedAccess = Papa.parse(accessText, { header: true }).data;
    const allFiles = Object.keys(parsedAccess[0] || {}).filter(key => key !== 'username');

    const baseName = currentFilename.replace(/\d*\.csv$/, '');
    const otherFiles = allFiles.filter(name => name.startsWith(baseName) && name !== currentFilename);

    // Load each of the other files
    for (let file of otherFiles) {
      try {
        const resp = await fetch(`../data/${file}`);
        if (resp.ok) {
          const text = await resp.text();
          const parsed = Papa.parse(text, { header: true }).data;
          allOtherData.push(...parsed);
        }
      } catch (e) {
        console.warn('Error loading file:', file);
      }
    }
  } catch (err) {
    console.error("Failed to load access.csv or files:", err);
    return;
  }

  function averageCountsPerLabel(dataSet) {
    const grouped = {};

    dataSet.forEach(row => {
      const group = Array.isArray(row) ? row[groupByIndex] : row[groupByCol];
      const value = Array.isArray(row) ? row[outcomeIndex] : row[outcomeColumn];
      if (!group || value === undefined) return;

      if (!grouped[group]) grouped[group] = {};
      if (!grouped[group][value]) grouped[group][value] = [];

      const parsedValue = parseFloat(value);
      grouped[group][value].push(isNaN(parsedValue) ? value : parsedValue);
    });

    const labelAvgs = outcomeLabels.map(label => {
      let total = 0;
      let count = 0;

      Object.values(grouped).forEach(labelGroup => {
        const values = labelGroup[label];
        if (!values || values.length === 0) return;

        count++;
        switch (stat) {
          case 'frequency':
            total += values.length;
            break;
          case 'mean':
            const numeric = values.filter(v => typeof v === 'number');
            const mean = numeric.reduce((a, b) => a + b, 0) / numeric.length || 0;
            total += mean;
            break;
          case 'median':
            const sorted = values.filter(v => typeof v === 'number').sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0
              ? (sorted[mid - 1] + sorted[mid]) / 2
              : sorted[mid];
            total += median || 0;
            break;
          default:
            break;
        }
      });

      return count > 0 ? total / count : 0;
    });

    return labelAvgs;
  }

  const orgAvg = averageCountsPerLabel(thisOrgData);
  const othersAvg = averageCountsPerLabel(allOtherData);
  
	console.log("📊 Org Avg", orgAvg);
	console.log("📊 Other Orgs Avg", othersAvg);
	console.log("📂 All Other Data sample (first row):", allOtherData[0]);
	console.log("🗂️ Total other rows loaded:", allOtherData.length);

	/*
  chartInstance.data.datasets.push({
    label: 'Org Avg',
    data: orgAvg,
    type: 'line',
    borderColor: '#36a2eb',
    borderDash: [5, 5],
    fill: false,
    pointRadius: 0
  });

  chartInstance.data.datasets.push({
    label: 'Other Orgs Avg',
    data: othersAvg,
    type: 'line',
    borderColor: '#aaa',
    borderDash: [2, 3],
    fill: false,
    pointRadius: 0
  });
	*/
	
	chartInstance.data.datasets.push({
	  label: 'Org Avg',
	  data: orgAvg,
	  type: 'line',
	  borderColor: '#9a1a50', // dark magenta to match branding
	  borderDash: [12, 3],
	  borderWidth: 0.8,
	  fill: false,
	  pointRadius: 0
	});

	
	chartInstance.data.datasets.push({
	  label: 'Other Orgs Avg',
	  data: othersAvg,
	  type: 'line',
	  borderColor: '#e55925', // orange to match branding
	  borderDash: [6, 3],
	  borderWidth: 0.5,
	  fill: false,
	  pointRadius: 0
	});
	
	
	/*
	chartInstance.data.datasets.push({
	  label: 'Other Orgs Avg',
	  data: othersAvg,
	  type: 'line',
	  borderColor: 'rgb(154, 26, 80)', // your dark magenta
	  borderWidth: 1, // hide the connecting line
	  pointStyle: 'cross', // ✖ shape
	  pointRadius: 5,      // size of the x's
	  pointBackgroundColor: 'rgb(154, 26, 80)', 
	  pointBorderColor: 'rgb(154, 26, 80)', 
	  pointHoverRadius: 6,
	  pointHoverBorderWidth: 1
	});
	*/

	
  chartInstance.update();
}


document.addEventListener('keydown', function(e) {
  if (e.key === 'a' && localChart) {
    localChart.data.datasets = localChart.data.datasets.filter(ds =>
      !['Org Avg', 'Other Orgs Avg'].includes(ds.label)
    );
    localChart.update();
  }
});
        
        function updateChart() {
			console.log('FIRE UPDATECHART');
            const primary1Selection = document.getElementById('primary1').value;
            const primary2Selections = getSelectedValues(document.getElementById('primary2'));
			console.log("PRIMARY2SELECTIONS", primary2Selections);
            const outcomes1Selection = getSelectedValues(document.getElementById('outcomes1'));

            // Filter data based on primary2 selection
            let filteredData = filterDataBasedOnSelections(primary1Selection, primary2Selections);

            const secondary1Selections = getSelectedValues(document.getElementById('secondary1'));
            filteredData = filterDataBasedOnAllSelections(filteredData, secondary1Selections);

            // Check if all selected outcomes are numerical
            const allNumerical = outcomes1Selection.every(selection => selection.startsWith('n'));

            let chartData;

            if (allNumerical) {
                // If all outcomes are numerical, calculate averages over time slices
                chartData = calculateAveragesOverTimeSlices(filteredData, outcomes1Selection);
            } else {
                // For mixed or purely categorical outcomes, process data as before
                chartData = processDataForChart(filteredData, outcomes1Selection, JSLIST);
            }

            // Render chart with the processed data
            renderChart(chartData);
            document.querySelector('.loading-spinner').style.display = 'none';
        }

        
        function getSelectedValues(selectElement) {
            return Array.from(selectElement.selectedOptions).map(option => option.value);
        }
        
        function filterDataBasedOnSelections(primary1Selection, primary2Selections) {
            // Find the index of the column selected in primary1 from the JSLIST headers
            const columnIndex = JSLIST[0].indexOf(primary1Selection);

            // If the column index is not found, log an error and return the full dataset
            if (columnIndex === -1) {
                console.error('Selected column not found in JSLIST headers:', primary1Selection);
                return JSLIST.slice(1); // or return []; for an empty dataset
            }

            // Filter JSLIST based on primary2 selections.
            // If "ALL" is selected in primary2, skip filtering by this column
            let filteredData = JSLIST.slice(1);
            if (!primary2Selections.includes("ALL")) {
                filteredData = filteredData.filter(row => primary2Selections.includes(row[columnIndex]));
            }

            console.log("1: FILTERED DATA")
            console.log(filteredData);
            
            return filteredData;
        }
        


        /*************************
         * PROCESS DATA FOR CHART - controls the graphs that appear
         * **********************/


        function processDataForChart(filteredData, outcomesSelection) {
            let datasets = [];
            const primary1Selection = document.getElementById('primary1').value; // Retrieve the primary1 selection
            const primary1Index = JSLIST[0].indexOf(primary1Selection); // Use primary1 to find the column index

            // Handle "ALL" selection uniformly
            const primary2Element = document.getElementById('primary2');
            let primary2Selections;
            if (primary2Element.querySelector('option:checked').text === "ALL") {
                // Consider all possible values as selected
                primary2Selections = [...new Set(filteredData.map(row => row[primary1Index]))];
            } else {
                primary2Selections = Array.from(primary2Element.selectedOptions).map(option => option.value);
            }

            const selectedStat = document.querySelector('input[name="stat"]:checked').value;
            let labels = determineLabelsBasedOnOutcome(filteredData, outcomesSelection, JSLIST);

            outcomesSelection.forEach(outcome => {
                const isCategorical = outcome.startsWith('c');
                const outcomeIndex = JSLIST[0].indexOf(outcome);

                if (isCategorical) {
                    let dataPerPrimary2Selection = {};

                    primary2Selections.forEach(selection => {
                        dataPerPrimary2Selection[selection] = {};
                        labels.forEach(label => {
                            dataPerPrimary2Selection[selection][label] = [];
                        });
                    });

                    filteredData.forEach(row => {
                        const category = row[outcomeIndex];
                        const primary2Value = row[primary1Index];

                        if (primary2Selections.includes(primary2Value) && labels.includes(category)) {
                            dataPerPrimary2Selection[primary2Value][category].push(parseFloat(row[outcomeIndex]) || 0);
                        }
                    });

                    primary2Selections.forEach(selection => {
                        let data = labels.map(label => {
                            let values = dataPerPrimary2Selection[selection][label];
                            switch (selectedStat) {
                                case "frequency":
                                    return values.length;
                                case "mean":
                                    return values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                                case "median":
                                    return medianc(values);
                                case "mode":
                                    return modec(values);
                                default:
                                    return 0;  // Default to zero if no data or invalid stat
                            }
                        });

                        datasets.push({
                            label: `${outcome} - ${selection}`,
                            data: data,
                            backgroundColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.5)`,
                        });
                    });
                } else {
                    // Handle numerical data (if necessary, adjust as needed)
                }
            });

            return { labels, datasets };
        }

        function medianc(values) {
            if (!values.length) return 0;
            values.sort((a, b) => a - b);
            const mid = Math.floor(values.length / 2);
            return values.length % 2 === 0 ? (values[mid - 1] + values[mid]) / 2 : values[mid];
        }

        function modec(values) {
            if (!values.length) return 0;
            const frequency = {};
            let maxFreq = 0;
            let modes = [];
            values.forEach(val => {
                frequency[val] = (frequency[val] || 0) + 1;
                if (frequency[val] > maxFreq) {
                    maxFreq = frequency[val];
                    modes = [val];
                } else if (frequency[val] === maxFreq) {
                    modes.push(val);
                }
            });
            return modes.length === 1 ? modes[0] : modes;
        }


        function determineLabelsBasedOnOutcome(filteredData, outcomesSelection, JSLIST) {
            // Default to using timestamps if specific logic for outcomes isn't defined
            let defaultLabelIndex = JSLIST[0].indexOf('c Timestamp'); // Adjust as needed

            // If the first selected outcome is categorical, use its categories as labels
            if (outcomesSelection.length > 0 && outcomesSelection[0].startsWith('c')) {
                const firstOutcomeIndex = JSLIST[0].indexOf(outcomesSelection[0]);
                // Use unique values from this category as labels
                const uniqueValues = [...new Set(filteredData.map(row => row[firstOutcomeIndex]))];
                return uniqueValues.length > 0 ? uniqueValues : ['No Data']; // Fallback to 'No Data' if empty
            }

            // If the first selection is numerical or no specific logic is defined, default to timestamps or another generic approach
            return filteredData.map(row => row[defaultLabelIndex] || 'No Label'); // Fallback to 'No Label' if undefined
        }



        function calculateAveragesOverTimeSlices(filteredData, numericalOutcomes) {
            const timestampIndex = JSLIST[0].indexOf('c Timestamp');
            const primary1Element = document.getElementById('primary1');
            const groupByColumn = primary1Element.options[primary1Element.selectedIndex].value;
            const groupByIndex = JSLIST[0].indexOf(groupByColumn);

            const primary2Element = document.getElementById('primary2');
            let selectedGroups;
            if (primary2Element.querySelector('option:checked').text === "ALL") {
                // If "ALL" is selected, use the text of all options except "ALL"
                selectedGroups = Array.from(primary2Element.options).map(option => option.text).filter(text => text !== "ALL");
            } else {
                selectedGroups = Array.from(primary2Element.selectedOptions).map(option => option.text);
            }

            const timestamps = filteredData.map(row => new Date(row[timestampIndex]).getTime()).sort((a, b) => a - b);
            const boundaries = [
                timestamps[0],
                timestamps[Math.floor(timestamps.length / 3)],
                timestamps[Math.floor(2 * timestamps.length / 3)],
                timestamps[timestamps.length - 1]
            ];

            function getBucketIndex(timestamp) {
                const ts = new Date(timestamp).getTime();
                return ts <= boundaries[1] ? 0 : ts <= boundaries[2] ? 1 : 2;
            }

            let groupedData = {};

            filteredData.forEach(row => {
                const groupValue = row[groupByIndex];
                if (selectedGroups.includes(groupValue)) {
                    if (!groupedData[groupValue]) {
                        groupedData[groupValue] = [[], [], []];
                    }
                    const bucketIndex = getBucketIndex(row[timestampIndex]);
                    numericalOutcomes.forEach(outcome => {
                        const outcomeIndex = JSLIST[0].indexOf(outcome);
                        const value = parseFloat(row[outcomeIndex]);
                        if (!isNaN(value)) {
                            groupedData[groupValue][bucketIndex].push(value);
                        }
                    });
                }
            });

            let datasets = [];
            Object.entries(groupedData).forEach(([groupValue, buckets]) => {
                let data = buckets.map(bucket => {
                    switch (document.querySelector('input[name="stat"]:checked').value) {
                        case 'mean':
                            return bucket.reduce((sum, curr) => sum + curr, 0) / bucket.length;
                        case 'median':
                            return median(bucket);
                        case 'mode':
                            return mode(bucket);
                        case 'frequency':
                            return bucket.length;
                        default:
                            return bucket.reduce((sum, curr) => sum + curr, 0) / bucket.length;  // default to mean
                    }
                });

                datasets.push({
                    label: groupValue,
                    data: data,
                    borderColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 1)`,
                    type: 'line',
                    fill: false
                });
            });

            return {
                labels: ['Start', 'Middle', 'End'],
                datasets: datasets
            };
        }

        function median(values) {
            if (values.length === 0) return 0;
            values.sort((a, b) => a - b);
            let mid = Math.floor(values.length / 2);
            return values.length % 2 === 0 ? (values[mid - 1] + values[mid]) / 2 : values[mid];
        }

        function mode(values) {
            let frequency = {}, max = 0, result = [];
            for (let v of values) {
                if (frequency[v]) frequency[v]++;
                else frequency[v] = 1;
                if (frequency[v] > max) {
                    max = frequency[v];
                    result = [v];
                } else if (frequency[v] === max) {
                    result.push(v);
                }
            }
            return result;
        }


        document.getElementById('primary2').addEventListener('change', function() {
            updateSecondary1Options();
        });

        function updateSecondary1Options() {
            const primary1Dropdown = document.getElementById('primary1');
            const primary1SelectedIndex = primary1Dropdown.selectedIndex; // Index in dropdown
            const primary1SelectedValue = primary1Dropdown.value; // Selected value, e.g., "District"
            const secondary1Options = [];

            // Assuming JSLIST[0] contains column headers and the rest are data rows
            JSLIST[0].forEach((column, columnIndex) => {
                // Skip the column that matches the primary1 selection
                if (column !== primary1SelectedValue) {
                    const uniqueValues = getUniqueValuesForColumn(columnIndex);
                    uniqueValues.forEach(value => {
                        // Format as "column name: value"
                        secondary1Options.push(`${column}: ${value}`);
                    });
                }
            });

            populateDropdown('secondary1', secondary1Options);
        }

        function getUniqueValuesForColumn(columnIndex) {
            const values = new Set(); // Use a Set to ensure uniqueness
            JSLIST.slice(1).forEach(row => {
                values.add(row[columnIndex]);
            });
            return [...values]; // Convert Set back to an array
        }

        function populateDropdown(dropdownId, options) {
            const dropdown = document.getElementById(dropdownId);
            dropdown.innerHTML = ''; // Clear existing options

            // Optionally add a default "Select" or "All" option
            const defaultOption = document.createElement('option');
            defaultOption.value = 'ALL';
            defaultOption.textContent = 'All';
            dropdown.appendChild(defaultOption);

            options.forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue; // Here, optionValue is already formatted
                option.textContent = optionValue; // Use the formatted string directly
                dropdown.appendChild(option);
            });

            dropdown.value = 'ALL';
        }

        document.getElementById('primary1').addEventListener('change', updateSecondary1Options);

        function filterDataBasedOnAllSelections(filteredData, secondary1Selections) {
            if (!secondary1Selections.includes("ALL")) {
                // Filter only if specific selections are made in secondary1
                return filteredData.filter(row => {
                    return secondary1Selections.some(selection => {
                        // Parse the selection into column name and value
                        const [columnName, value] = selection.split(': ').map(s => s.trim());
                        const columnIndex = JSLIST[0].indexOf(columnName);
                        return row[columnIndex] === value;
                    });
                });
            }
            // Return the data as-is if "ALL" is selected or no secondary1 selections are made
            return filteredData;
        }
		

        /***************************
         * Populate Presets
         * ************************/

		
		const presetOptions = [
			'Scores over time of all Schools',
			'Race Distribution within a District',
			'Scores of Students from Economically Disadvantaged Backgrounds'
		];

		
		function populatePresetsDropdown() {
			const presetsSelect = document.getElementById('presets1');
			presetsSelect.innerHTML = ''; // Clear existing options

			presetOptions.forEach(optionText => {
				const option = new Option(optionText, optionText);
				presetsSelect.add(option);
			});
		}

		// Call this function to populate the dropdown on page load
		populatePresetsDropdown();

        /***************************
         * Update Chart using presets
         * ************************/

        function getSelectedValues(selectElement) { // get selected values; Helper function for when preset is getting multiple values
            var values = [];
            for (var i = 0; i < selectElement.options.length; i++) {
                if (selectElement.options[i].selected) {
                    values.push(selectElement.options[i].value);
                }
            }
            return values;
        }


function forceSelectOptions(selectId, indices) {
    var select = document.getElementById(selectId);
    Array.from(select.options).forEach(option => option.selected = indices.includes(option.index));
}

function selectFirstOptionOnly(selectId) {
    var select = document.getElementById(selectId);
    Array.from(select.options).forEach((option, index) => {
        option.selected = index === 0; // Only the first option is selected
    });
}



function updateChartUsingPreset() {
    console.log('FIRE UPDATECHARTUSINGPRESET');
    const selectedPreset = document.getElementById('presets1').value;
    const selectedDataSource = document.getElementById('datasource1').value;

    document.querySelector('input[name="stat"][value="frequency"]').checked = true;

    console.log("Selected Preset: ", selectedPreset);

    if (window.customPresets && window.customPresets[selectedPreset]) {
        const preset = window.customPresets[selectedPreset];
        console.log("Preset Details: ", preset);

        // Check if the preset's dataset matches the currently selected one
        if (preset.dataSource && preset.dataSource !== selectedDataSource) {
            console.log(`Switching data source from ${selectedDataSource} to ${preset.dataSource}`);

            // Set the data source dropdown to the preset's dataset
            document.getElementById('datasource1').value = preset.dataSource;

            // Trigger the dataset change event to load the new dataset
            fetchCSVData(() => {
                console.log(`Dataset ${preset.dataSource} loaded. Now applying preset.`);
                applyPresetSettings(preset); // Apply the preset after dataset loads
            });

            return; // Stop further execution, preset will be applied after dataset loads
        }

        // If the dataset is the same, apply preset immediately
        applyPresetSettings(preset);
    } else {
        console.warn("Preset not found or no preset selected.");
    }
}

function applyPresetSettings(preset) {
    console.log("Applying preset settings...");

    // Set primary1, primary2, secondary1, outcomes1 dropdowns based on preset values
    setupDropdown('primary1', preset.primary1, false);
    setupDropdown('primary2', preset.primary2, false);
    setupDropdown('secondary1', preset.secondary1, true);
    setupDropdown('outcomes1', preset.outcomes1, false);

    // Set the stat radio button based on the preset
    document.querySelector(`input[name="stat"][value="${preset.stat}"]`).checked = true;

    // Select the options in primary2 dropdown
    const primary2 = document.getElementById('primary2');
    Array.from(primary2.options).forEach(option => option.selected = false);

    if (preset.primary2 && preset.primary2.length > 0) {
        preset.primary2.forEach(value => {
            const option = Array.from(primary2.options).find(opt => opt.value === value);
            if (option) {
                option.selected = true;
            }
        });
    }

    // Manually trigger change events after setup
    ['primary1'].forEach(id => {
        const event = new Event('change');
        document.getElementById(id).dispatchEvent(event);
    });

    console.log("Preset applied successfully.");
}




document.getElementById('presets1').addEventListener('change', updateChartUsingPreset);



function addPreset() {
    const presetName = prompt("Enter a name for your new preset:");
    if (!presetName) {
        alert("Preset name cannot be empty!");
        return;
    }

    const primary1Index = document.getElementById('primary1').selectedIndex;
    const primary2Indices = Array.from(document.getElementById('primary2').selectedOptions).map(opt => opt.index);
    const secondary1Indices = Array.from(document.getElementById('secondary1').selectedOptions).map(opt => opt.index);
    const outcomes1Indices = Array.from(document.getElementById('outcomes1').selectedOptions).map(opt => opt.index);
    const stat = document.querySelector('input[name="stat"]:checked').value;
    const dataSource = document.getElementById('datasource1').value; // Get selected data source

    const newPreset = {
        primary1: primary1Index,
        primary2: primary2Indices,
        secondary1: secondary1Indices,
        outcomes1: outcomes1Indices,
        stat,
        dataSource // Store the data source in the preset
    };

    // Store the new preset in window.customPresets
    window.customPresets[presetName] = newPreset;

    // Save the updated presets to localStorage
    savePresetsToStorage();

    // Add the new preset to the dropdown
    const presetSelect = document.getElementById('presets1');
    const option = new Option(presetName, presetName);
    presetSelect.add(option);
    presetSelect.value = presetName; // Select the new preset immediately

    updateChartUsingPreset(); // Apply the new preset immediately
}



function setupDropdown(selectId, indices, isAll = false) {
	console.log('FIRE SETUPDROPDOWN');
    const select = document.getElementById(selectId);
    
    // Clear all selections first
    Array.from(select.options).forEach(option => {
        option.selected = false;
    });

    if (isAll) {
        // If 'ALL' is intended, select the first option or all options based on specific use-case
        select.options[0].selected = true;
    } else {
        // Convert indices to array if not already, to handle both single and multiple selections
        indices = Array.isArray(indices) ? indices : [indices];

        // Set selected based on indices
        indices.forEach(index => {
            if (select.options[index]) {
                select.options[index].selected = true;
            }
        });
    }
}



document.addEventListener('DOMContentLoaded', function() {
    loadPresetsFromStorage();
    document.getElementById('presets1').addEventListener('change', updateChartUsingPreset);
    document.getElementById('addPresetButton').addEventListener('click', addPreset);
});

// Hardcoded default presets
const defaultPresets = {
    "Sample Preset 1": { primary1: 1, primary2: 0, secondary1: 0, outcomes1: 3, stat: "frequency" },
    "Sample Preset 2": { primary1: 1, primary2: 0, secondary1: 0, outcomes1: 4, stat: "frequency" },
    "Sample Preset 3": { primary1: 1, primary2: 0, secondary1: 0, outcomes1: 5, stat: "frequency" }
};

// Function to load presets from localStorage
function loadPresetsFromStorage() {
    const storedPresets = JSON.parse(localStorage.getItem('customPresets')) || {};

    // Combine default presets with stored presets
    window.customPresets = { ...defaultPresets, ...storedPresets };

    // Populate the presets dropdown
    const presetSelect = document.getElementById('presets1');
    presetSelect.innerHTML = ''; // Clear existing options

    Object.keys(window.customPresets).forEach(presetName => {
        const option = new Option(presetName, presetName);
        presetSelect.add(option);
    });
}

// Function to save presets to localStorage
function savePresetsToStorage() {
    localStorage.setItem("customPresets", JSON.stringify(window.customPresets));
}


document.getElementById('exportPresetsButton').addEventListener('click', function() {
	const customPresets = localStorage.getItem('customPresets');
	const blob = new Blob([customPresets], { type: 'application/json' });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = 'presets.json';
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
});

document.getElementById('importPresetsInput').addEventListener('change', function(event) {
	const file = event.target.files[0];
	if (file) {
		const reader = new FileReader();
		reader.onload = function(e) {
			const importedPresets = e.target.result;
			localStorage.setItem('customPresets', importedPresets);
			// Optionally, refresh the page or update the presets dropdown
			location.reload();
		};
		reader.readAsText(file);
	}
});


      </script>
  </body>
</html>
